#include "imports/stdlib.fc";
#include "constants.fc";
#include "messages.fc";
#include "params.fc";
#include "utils.fc";

{-
    storage#_
        admin_address:MsgAddress storage_contract_code:^Cell bag_storage_contracts:^Cell = Storage;
-}
(slice, cell, cell) load_data() inline {
    slice ds = get_data().begin_parse();

    var admin_address = ds~load_msg_addr();
    var storage_contract_code = ds~load_ref();

    var bag_storage_contracts_dict = new_dict();
    if (~ slice_empty?(ds)) {
        bag_storage_contracts_dict = ds~load_dict();
    }

    return (admin_address, storage_contract_code, bag_storage_contracts_dict);
}

() save_data(slice admin_address, cell storage_contract_code, cell bag_storage_contracts) impure inline {
    set_data(
        begin_cell()
            .store_slice(admin_address)
            .store_ref(storage_contract_code)
            .store_dict(bag_storage_contracts)
            .end_cell()
    );
}

cell load_bag_storage_contracts_dict() inline {
    (slice admin_address, cell storage_contract_code, cell bag_storage_contracts) = load_data();
    return bag_storage_contracts;
}

() save_bag_storage_contracts_dict(cell bags_dict) impure inline {
    (slice admin_address, cell storage_contract_code, _) = load_data();
    save_data(admin_address, storage_contract_code, bags_dict);
}

() deploy_storage_contract(
    cell storage_contract_code, slice owner_address, int query_id,
    int torrent_hash, int file_size, int merkle_hash, int initial_storage_fee
) impure {
    throw_unless(error::file_too_small, file_size >= minimal_file_size);
    throw_unless(error::file_too_large, file_size <= maximal_file_size);

    cell state_init = build_storage_contract_stateinit(
        storage_contract_code, torrent_hash, owner_address, merkle_hash, file_size, initial_storage_fee
    );
    slice storage_contract_address = calculate_storage_contract_address(state_init);

    cell bags_dict = load_bag_storage_contracts_dict();
    var (_, success?) = bags_dict.udict_get?(256, torrent_hash);
    if (success?) {
        throw(error::duplicated_torrent_hash);
    }
    bags_dict~udict_set(256, torrent_hash, storage_contract_address);
    save_bag_storage_contracts_dict(bags_dict);

    cell master_msg = begin_cell().end_cell();
    var msg = begin_cell()
        .store_msg_flag(msg_flag::non_bounceable)
        .store_slice(storage_contract_address)
        .store_coins(0)  ;; storage fees and additional gas are sent via `CARRY_REMAINING_GAS` flag
        .store_msgbody_prefix_stateinit(state_init, master_msg); ;; store_uint(4 + 2 + 1, 1 + 4 + 4 + 64 + 32 + 1 + 1 + 1).store_ref(state_init).store_ref(ref);
    send_raw_message(msg.end_cell(), CARRY_REMAINING_GAS);
}

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) { ;; ignore empty messages
        return ();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }
    slice sender_address = cs~load_msg_addr();

    cs~load_msg_addr(); ;; skip dst
    cs~load_coins(); ;; skip value
    cs~skip_bits(1); ;; skip extracurrency collection
    cs~load_coins(); ;; skip ihr_fee
    int fwd_fee = muldiv(cs~load_coins(), 3, 2); ;; we use message fwd_fee for estimation of forward_payload costs
  
    int op = in_msg_body~load_op();
    int query_id = in_msg_body~load_query_id();

    (slice admin_address, cell storage_contract_code, cell bag_storage_contracts) = load_data();

    if (op == op::update_admin) {
        throw_unless(error::unauthorized, equal_slice_bits(sender_address, admin_address));
        slice new_admin_address = in_msg_body~load_msg_addr();
        save_data(new_admin_address, storage_contract_code, bag_storage_contracts);
        return ();
    }

    if (op == op::place_storage_order) {
        int torrent_hash = in_msg_body~load_uint(256);
        int file_size = in_msg_body~load_uint(64);
        int merkle_hash = in_msg_body~load_uint(256);
        int total_storage_fee = in_msg_body~load_coins(); ;; VarUInteger 16

        throw_unless(error::not_enough_storage_fee, total_storage_fee >= min_storage_fee);
        throw_unless(error::not_enough_storage_fee, msg_value >= total_storage_fee);

        deploy_storage_contract(storage_contract_code, sender_address, query_id, torrent_hash, file_size, merkle_hash, total_storage_fee);

        return ();
    }

    throw(error::unknown_op);
}

slice get_admin_address() method_id {
    (slice admin_address, cell storage_contract_code, cell bag_storage_contracts) = load_data();
    return admin_address;
}

slice get_storage_contract_address(int torrent_hash) method_id {
    ;; var torrent_hash = torrent_hash_cell~load_uint(256);

    cell bags_dict = load_bag_storage_contracts_dict();
    var (val, success?) = bags_dict.udict_get?(256, torrent_hash);
    if (success?) {
        return val~load_msg_addr();
    }
    return null();
}