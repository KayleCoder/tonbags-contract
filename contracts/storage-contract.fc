#include "imports/stdlib.fc";
#include "constants.fc";
#include "messages.fc";

(slice, int) begin_parse_special(cell c) asm "x{D739} s,";

{-
    storage#_
        bag_info:^Cell rewards_params:^Cell storage_providers:^Cell
        storage_provider_last_proof_times^Cell, storage_provider_next_proofs^Cell,
        total_rewards_settled_and_unclaimed_for_providers^Cell,
        per_sec_total_rewards_settled_for_providers^Cell = Storage;
-}
(cell, cell, cell, cell, cell, cell, cell) load_data() inline {
    var ds = get_data().begin_parse();

    var (
        bag_info, rewards_params, storage_providers, storage_provider_last_proof_times, storage_provider_next_proofs, total_rewards_settled_and_unclaimed_for_providers, per_sec_total_rewards_settled_for_providers
    ) = (
        ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_ref()
    );
    return (
        bag_info, rewards_params, storage_providers, storage_provider_last_proof_times, storage_provider_next_proofs, total_rewards_settled_and_unclaimed_for_providers, per_sec_total_rewards_settled_for_providers
    );
}

(int, slice, int, int) load_bag_info() inline {
    var ds = get_data().begin_parse();
    var (bag_info, residue) = (ds~load_ref(), ds);
    
    ds = bag_info.begin_parse();
    var (
        torrent_hash, owner_address, file_merkle_hash, file_size_in_bytes
    ) = (
        ds~load_uint(256), ds~load_msg_addr(), ds~load_uint(256), ds~load_uint(64)
    );
    return (torrent_hash, owner_address, file_merkle_hash, file_size_in_bytes);
}

(int, int, int, int, int, int, int, int) load_rewards_params() inline {
    var ds = get_data().begin_parse();
    var (_, rewards_params, residue) = (ds~load_ref(), ds~load_ref(), ds);

    ds = rewards_params.begin_parse();
    var (
        started, total_storage_providers, total_rewards, total_rewards_per_sec, undistributed_rewards,
        per_sec_per_provider_total_rewards_settled, period_finish, last_settle_time
    ) = (
        ds~load_uint(1), ds~load_uint(32), ds~load_coins(), ds~load_coins(), ds~load_coins(),
        ds~load_coins(), ds~load_uint(32), ds~load_uint(32)
    );

    return (
        started, total_storage_providers, total_rewards, total_rewards_per_sec, undistributed_rewards,
        per_sec_per_provider_total_rewards_settled, period_finish, last_settle_time
    );
}

() save_rewards_params(
    started, total_storage_providers, total_rewards, total_rewards_per_sec, undistributed_rewards,
    per_sec_per_provider_total_rewards_settled, period_finish, last_settle_time
) impure {
    var ds = get_data().begin_parse();
    var (
        bag_info, _, residue
    ) = (
        ds~load_ref(), ds~load_ref(), ds
    );
    var rewards_params = begin_cell()
        .store_uint(started, 1)
        .store_uint(total_storage_providers, 32)
        .store_coins(total_rewards)
        .store_coins(total_rewards_per_sec)
        .store_coins(undistributed_rewards)
        .store_coins(per_sec_per_provider_total_rewards_settled)
        .store_uint(period_finish, 32)
        .store_uint(last_settle_time, 32)
        .end_cell();

    set_data(
        begin_cell()
            .store_ref(bag_info)
            .store_ref(rewards_params)
            .store_slice(residue)
            .end_cell()
    );
}

cell load_storage_providers_dict() inline {
    var ds = get_data().begin_parse();
    var (
        _, _, storage_providers, residue
    ) = (
        ds~load_ref(), ds~load_ref(), ds~load_ref(), ds
    );
    return storage_providers;
}

() save_storage_providers_dict(cell storage_providers_dict) impure inline {
    var ds = get_data().begin_parse();
    var (
        bag_info, rewards_params, _, residue
    ) = (
        ds~load_ref(), ds~load_ref(), ds~load_ref(), ds
    );
    set_data(
        begin_cell()
            .store_ref(bag_info)
            .store_ref(rewards_params)
            .store_ref(storage_providers_dict)
            .store_slice(residue)
            .end_cell()
    );
}

cell load_storage_provider_last_proof_times() inline {
    var ds = get_data().begin_parse();
    var (
        _, _, _, storage_provider_last_proof_times, residue
    ) = (
        ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_dict(), ds
    );

    return storage_provider_last_proof_times;
}

() save_storage_provider_last_proof_times(cell storage_provider_last_proof_times) impure inline {
    var ds = get_data().begin_parse();
    var (
        bag_info, rewards_params, storage_providers, _, residue
    ) = (
        ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_ref(), ds
    );
    set_data(
        begin_cell()
            .store_ref(bag_info)
            .store_ref(rewards_params)
            .store_ref(storage_providers)
            .store_ref(storage_provider_last_proof_times)
            .store_slice(residue)
            .end_cell()
    );
}

cell load_storage_provider_next_proofs() inline {
    var ds = get_data().begin_parse();
    var (
        _, _, _, _, storage_provider_next_proofs, residue
    ) = (
        ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_dict(), ds
    );
    return storage_provider_next_proofs;
}

() save_storage_provider_next_proofs(cell storage_provider_next_proofs) impure inline {
    var ds = get_data().begin_parse();
    var (
        bag_info, rewards_params, storage_providers, storage_provider_last_proof_times, storage_provider_next_proofs, _, residue
    ) = (
        ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_ref(), ds
    );
    set_data(
        begin_cell()
            .store_ref(bag_info)
            .store_ref(rewards_params)
            .store_ref(storage_providers)
            .store_ref(storage_provider_last_proof_times)
            .store_ref(storage_provider_next_proofs)
            .store_slice(residue)
            .end_cell()
    );

}

cell load_total_rewards_settled_and_unclaimed_for_providers() inline {
    var ds = get_data().begin_parse();
    var (
        _, _, _, _, _, total_rewards_settled_and_unclaimed_for_providers, residue
    ) = (
        ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_dict(), ds
    );
    return total_rewards_settled_and_unclaimed_for_providers;
}

() save_total_rewards_settled_and_unclaimed_for_providers(cell total_rewards_settled_and_unclaimed_for_providers) impure inline {
    var ds = get_data().begin_parse();
    var (
        bag_info, rewards_params, storage_providers, storage_provider_last_proof_times, storage_provider_next_proofs, _, residue
    ) = (
        ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_ref(), ds
    );
    set_data(
        begin_cell()
            .store_ref(bag_info)
            .store_ref(rewards_params)
            .store_ref(storage_providers)
            .store_ref(storage_provider_last_proof_times)
            .store_ref(storage_provider_next_proofs)
            .store_ref(total_rewards_settled_and_unclaimed_for_providers)
            .store_slice(residue)
            .end_cell()
    );
}

cell load_per_sec_total_rewards_settled_for_providers() inline {
    var ds = get_data().begin_parse();
    var (
        _, _, _, _, _, _, per_sec_total_rewards_settled_for_providers
    ) = (
        ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_dict()
    );
    return per_sec_total_rewards_settled_for_providers;
}

() save_per_sec_total_rewards_settled_for_providers(cell per_sec_total_rewards_settled_for_providers) impure inline {
    var ds = get_data().begin_parse();
    var (
         bag_info, rewards_params, storage_providers, storage_provider_last_proof_times, storage_provider_next_proofs, total_rewards_settled_and_unclaimed_for_providers, _
    ) = (
        ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_ref(), ds~load_dict()
    );
    set_data(
        begin_cell()
            .store_ref(bag_info)
            .store_ref(rewards_params)
            .store_ref(storage_providers)
            .store_ref(storage_provider_last_proof_times)
            .store_ref(storage_provider_next_proofs)
            .store_ref(total_rewards_settled_and_unclaimed_for_providers)
            .store_ref(per_sec_total_rewards_settled_for_providers)
            .end_cell()
    );
}

int load_total_storage_providers() inline {
    var (
        started, total_storage_providers, total_rewards, total_rewards_per_sec, undistributed_rewards,
        per_sec_per_provider_total_rewards_settled, period_finish, last_settle_time
    ) = load_rewards_params();
    return total_storage_providers;
}

int settle_time_applicable() inline {
    var (
        started, total_storage_providers, total_rewards, total_rewards_per_sec, undistributed_rewards,
        per_sec_per_provider_total_rewards_settled, period_finish, last_settle_time
    ) = load_rewards_params();
    return (now() <= period_finish) ? now() : period_finish;
}

int per_sec_per_provider_total_rewards_till_now() inline {
    var (
        started, total_storage_providers, total_rewards, total_rewards_per_sec, undistributed_rewards,
        per_sec_per_provider_total_rewards_settled, period_finish, last_settle_time
    ) = load_rewards_params();
    if (total_storage_providers == 0) {
        return per_sec_per_provider_total_rewards_settled;
    }
    else {
        return per_sec_per_provider_total_rewards_settled + (
            (settle_time_applicable() - last_settle_time) * total_rewards_per_sec * (10 ^ 18) / total_storage_providers / (10 ^ 18)
        );
    }
}

int per_sec_total_rewards_pending_settle_for_provider(slice provider_address) inline {
    (int wc, int provider_addr) = parse_std_addr(provider_address);

    var dict = load_per_sec_total_rewards_settled_for_providers();
    var (val, found?) = dict.udict_get?(256, provider_addr);
    if (~ found?) {
        return 0;
    }
    return per_sec_per_provider_total_rewards_till_now() - val~load_coins();
}

() do_settle_rewards(slice provider_address, int newWorker, int settle_new_rewards) impure {
    (int wc, int provider_addr) = parse_std_addr(provider_address);

    var per_sec_per_provider_total_rewards_settled = per_sec_per_provider_total_rewards_till_now();
    var last_settle_time = settle_time_applicable();
    if (newWorker) {
        var total_rewards_settled_and_unclaimed_for_providers = load_total_rewards_settled_and_unclaimed_for_providers();
        total_rewards_settled_and_unclaimed_for_providers.udict_set_ref(256, provider_addr, begin_cell().store_coins(0).end_cell());
        save_total_rewards_settled_and_unclaimed_for_providers(total_rewards_settled_and_unclaimed_for_providers);
    }
    if (settle_new_rewards) {
        var pending_settled = per_sec_total_rewards_pending_settle_for_provider(provider_address);

        var total_rewards_settled_and_unclaimed_for_providers = load_total_rewards_settled_and_unclaimed_for_providers();
        var (earned, success?) = total_rewards_settled_and_unclaimed_for_providers.udict_get?(256, provider_addr);
        if (success?) {
            var new_earned = earned~load_coins() + pending_settled;
            total_rewards_settled_and_unclaimed_for_providers.udict_set_ref(256, provider_addr, begin_cell().store_coins(new_earned).end_cell());
        }

        save_total_rewards_settled_and_unclaimed_for_providers(total_rewards_settled_and_unclaimed_for_providers);
    }

    var per_sec_total_rewards_settled_for_providers = load_per_sec_total_rewards_settled_for_providers();
    per_sec_total_rewards_settled_for_providers.udict_set_ref(256, provider_addr, begin_cell().store_coins(per_sec_per_provider_total_rewards_settled).end_cell());
    save_per_sec_total_rewards_settled_for_providers(per_sec_total_rewards_settled_for_providers);

}

() register_as_provider(slice provider_address) impure {
    (int wc, int provider_addr) = parse_std_addr(provider_address);

    var storage_providers_dict = load_storage_providers_dict();
    var (_, success?) = storage_providers_dict.udict_get?(256, provider_addr);
    if (success?) {
        throw(error::storage_provider_already_registered);
    }
    do_settle_rewards(provider_address, 1, 0);

    var first_worker = storage_providers_dict.dict_empty?();
    var (
        started, total_storage_providers, total_rewards, total_rewards_per_sec, undistributed_rewards,
        per_sec_per_provider_total_rewards_settled, period_finish, last_settle_time
    ) = load_rewards_params();
    if (~ started & first_worker) {
        started = 1;
        total_rewards_per_sec = total_rewards / default_storage_period;
        last_settle_time = now();
        period_finish = now() + default_storage_period;
    }
    total_storage_providers += 1;
    save_rewards_params(
        started, total_storage_providers, total_rewards, total_rewards_per_sec, undistributed_rewards,
        per_sec_per_provider_total_rewards_settled, period_finish, last_settle_time
    );

    storage_providers_dict.udict_set_ref(256, provider_addr, begin_cell().store_uint(1, 1).end_cell());
    save_storage_providers_dict(storage_providers_dict);

    var (torrent_hash, owner_address, file_merkle_hash, file_size_in_bytes) = load_bag_info();
    var next_proof = rand(file_size_in_bytes);
    var storage_provider_next_proofs_dict = load_storage_provider_next_proofs();
    storage_provider_next_proofs_dict.udict_set_ref(256, provider_addr, begin_cell().store_uint(64, next_proof).end_cell());
    save_storage_provider_next_proofs(storage_provider_next_proofs_dict);

    var last_work_report_time_dict = load_storage_provider_last_proof_times();
    last_work_report_time_dict.udict_set_ref(256, provider_addr, begin_cell().store_uint(32, now()).end_cell());
    save_storage_provider_last_proof_times(last_work_report_time_dict);
}

() exit(slice provider_address) impure {
    (int wc, int provider_addr) = parse_std_addr(provider_address);

    var storage_providers_dict = load_storage_providers_dict();
    var (_, success?) = storage_providers_dict.udict_get?(256, provider_addr);
    if (~ success?) {
        throw(error::unregistered_storage_provider);
    }

    var pending_rewards = per_sec_total_rewards_pending_settle_for_provider(provider_address);
    var (
        started, total_storage_providers, total_rewards, total_rewards_per_sec, undistributed_rewards,
        per_sec_per_provider_total_rewards_settled, period_finish, last_settle_time
    ) = load_rewards_params();
    total_storage_providers -= 1;
    undistributed_rewards += pending_rewards;
    save_rewards_params(
        started, total_storage_providers, total_rewards, total_rewards_per_sec, undistributed_rewards,
        per_sec_per_provider_total_rewards_settled, period_finish, last_settle_time
    );

    do_settle_rewards(provider_address, 0, 1);

    storage_providers_dict.udict_delete?(256, provider_addr);
    save_storage_providers_dict(storage_providers_dict);

    var last_work_report_time_dict = load_storage_provider_last_proof_times();
    last_work_report_time_dict.udict_delete?(256, provider_addr);
    save_storage_provider_last_proof_times(last_work_report_time_dict);
}

() claim_rewards(slice provider_address) impure {
    (int wc, int provider_addr) = parse_std_addr(provider_address);
    do_settle_rewards(provider_address, 0, 0);

    var total_rewards_settled_and_unclaimed_for_providers = load_total_rewards_settled_and_unclaimed_for_providers();
    var (earned, success?) = total_rewards_settled_and_unclaimed_for_providers.udict_get?(256, provider_addr);
    if (success?) {
        total_rewards_settled_and_unclaimed_for_providers.udict_set_ref(256, provider_addr, begin_cell().store_coins(0).end_cell());
        save_total_rewards_settled_and_unclaimed_for_providers(total_rewards_settled_and_unclaimed_for_providers);
        cell msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(provider_address)
            .store_coins(earned~load_coins())
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(0, 32) ;; zero opcode
            .end_cell();
        send_raw_message(msg, 3);
    }
}

() recycle(slice caller_address, slice to_address) impure {
    var (
        torrent_hash, owner_address, file_merkle_hash, file_size_in_bytes
    ) = load_bag_info();
    throw_unless(error::unauthorized, equal_slice_bits(caller_address, owner_address));

    var (
        started, total_storage_providers, total_rewards, total_rewards_per_sec, undistributed_rewards,
        per_sec_per_provider_total_rewards_settled, period_finish, last_settle_time
    ) = load_rewards_params();
    throw_unless(error::storage_order_unexpired, (period_finish > 0) & (now() > period_finish));

    if (undistributed_rewards > 0) {
        cell msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(to_address)
            .store_coins(undistributed_rewards)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(0, 32) ;; zero opcode
            .end_cell();
        send_raw_message(msg, 3);

        undistributed_rewards = 0;
        save_rewards_params(
            started, total_storage_providers, total_rewards, total_rewards_per_sec, undistributed_rewards,
            per_sec_per_provider_total_rewards_settled, period_finish, last_settle_time
        );
    }
}

int check_proof(int merkle_hash, int byte_to_proof, int file_size, cell file_dict_proof) {
    (slice cs, int special) = file_dict_proof.begin_parse_special();
    if (~ special) {
        return false;
    }
    if (cs~load_uint(8) != 3) { ;; Merkle proof
        return false;
    }
    if (cs~load_uint(256) != merkle_hash) {
        return false;
    }
    cell file_dict = cs~load_ref();
    int key_len = 0;
    while ((CHUNK_SIZE << key_len) < file_size) {
        key_len += 1;
    }
    (slice data, int found?) = file_dict.udict_get?(key_len, byte_to_proof / CHUNK_SIZE);
    if (found?) {
        return true;
    }
    return false;
}

() on_submit_storage_proof(slice provider_address, int valid) impure {
    (int wc, int provider_addr) = parse_std_addr(provider_address);

    var storage_providers_dict = load_storage_providers_dict();
    var (_, success?) = storage_providers_dict.udict_get?(256, provider_addr);
    if (~ success?) {
        throw(error::unregistered_storage_provider);
    }
    if (~ valid) {
        return ();
    }

    var last_work_report_time = 0;
    var last_work_report_time_dict = load_storage_provider_last_proof_times();
    var (val, found?) = last_work_report_time_dict.udict_get?(256, provider_addr);
    if (found?) {
        last_work_report_time = val~load_uint(32);
    }

    var in_report_window = now() - last_work_report_time <= max_storage_proof_span;
    if (~ in_report_window) {
        var (
            started, total_storage_providers, total_rewards, total_rewards_per_sec, undistributed_rewards,
            per_sec_per_provider_total_rewards_settled, period_finish, last_settle_time
        ) = load_rewards_params();
        undistributed_rewards += per_sec_total_rewards_pending_settle_for_provider(provider_address);
        save_rewards_params(
            started, total_storage_providers, total_rewards, total_rewards_per_sec, undistributed_rewards,
            per_sec_per_provider_total_rewards_settled, period_finish, last_settle_time
        );
    }

    do_settle_rewards(provider_address, 0, in_report_window);

    var last_work_report_time_dict = load_storage_provider_last_proof_times();
    last_work_report_time_dict.udict_set_ref(256, provider_addr, begin_cell().store_uint(32, now()).end_cell());
    save_storage_provider_last_proof_times(last_work_report_time_dict);
}

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }
    slice sender_address = cs~load_msg_addr();
    (int wc, int sender_addr) = parse_std_addr(sender_address);
    if (in_msg_body.slice_empty?()) {
        throw(error::unknown_op);
    }

    int op = in_msg_body~load_uint(32);
    if (op == 0) {
        throw(error::unknown_op);
    }

    int query_id = in_msg_body~load_uint(64);
    if (op == op::register_as_storage_provider) {
        register_as_provider(sender_address);
        return ();
    }
    if (op == op::unregister_as_storage_provider) {
        exit(sender_address);
        return ();
    }
    if (op == op::claim_storage_rewards) {
        claim_rewards(sender_address);
        return ();
    }

    if (op == op::submit_storage_proof) {
        cell file_dict_proof = in_msg_body~load_ref();

        var (
            torrent_hash, owner_address, file_merkle_hash, file_size_in_bytes
        ) = load_bag_info();
        var storage_provider_next_proofs_dict = load_storage_provider_next_proofs();

        var (val, found?) = storage_provider_next_proofs_dict.udict_get?(256, sender_addr);
        if (~ found?) {
            throw(error::invalid_state);
        }
        var next_proof = val~load_uint(64);
        var valid = check_proof(file_merkle_hash, next_proof, file_size_in_bytes, file_dict_proof);

        next_proof = rand(file_size_in_bytes);
        storage_provider_next_proofs_dict.udict_set_ref(256, sender_addr, begin_cell().store_uint(64, next_proof).end_cell());
        save_storage_provider_next_proofs(storage_provider_next_proofs_dict);

        on_submit_storage_proof(sender_address, valid);
        return ();
    }

    if (op == op::recycle_undistributed_storage_fees) {
        slice to_address = cs~load_msg_addr();
        recycle(sender_address, to_address);
        return ();
    }
}

int earned(slice provider_address) method_id {
    (int wc, int provider_addr) = parse_std_addr(provider_address);
    var total_rewards_settled_and_unclaimed_for_providers = load_total_rewards_settled_and_unclaimed_for_providers();
    var (earned, success?) = total_rewards_settled_and_unclaimed_for_providers.udict_get?(256, provider_addr);
    if (success?) {
        return earned~load_coins();
    }
    return 0;
}