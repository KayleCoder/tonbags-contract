#include "imports/stdlib.fc";
#include "constants.fc";
#include "messages.fc";

{-
    storage#_
        bag_info:^Cell rewards_params:^Cell storage_providers:^Cell
        storage_provider_last_proof_times^Cell, storage_provider_next_proofs^Cell,
        total_rewards_settled_and_unclaimed_for_providers^Cell,
        per_sec_total_rewards_settled_for_providers^Cell = Storage;
-}
(cell, cell, cell, cell, cell, cell, cell) load_data() inline {
    var ds = get_data().begin_parse();

    var (
        bag_info, rewards_params, storage_providers, storage_provider_last_proof_times, storage_provider_next_proofs, total_rewards_settled_and_unclaimed_for_providers, per_sec_total_rewards_settled_for_providers
    ) = (
        ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_ref()
    );
    return (
        bag_info, rewards_params, storage_providers, storage_provider_last_proof_times, storage_provider_next_proofs, total_rewards_settled_and_unclaimed_for_providers, per_sec_total_rewards_settled_for_providers
    );
}

(int, slice, int, int) load_bag_info() inline {
    var ds = get_data().begin_parse().load_ref();
    var (
        torrent_hash, owner_address, file_merkle_hash, file_size_in_bytes
    ) = (
        ds~load_uint(256), ds~load_msg_addr(), ds~load_uint(256), ds~load_uint(64)
    );
    return (torrent_hash, owner_address, file_merkle_hash, file_size_in_bytes);
}

(int, int, int, int, int, int, int, int) load_rewards_params() inline {
    var ds = get_data().begin_parse().skip_ref().load_ref();

    var (
        started, total_rewards, total_rewards_per_sec, undistributed_rewards,
        per_sec_per_provider_total_rewards_settled, period_finish, last_settle_time
    ) = (
        ds~load_uint(1), ds~load_coins(), ds~load_coins(), ds~load_coins(),
        ds~load_coins(), ds~load_uint(32), ds~load_uint(32)
    );

    return (
        total_rewards, total_rewards_per_sec, undistributed_rewards,
        per_sec_per_provider_total_rewards_settled, period_finish, last_settle_time
    );
}

cell save_rewards_parms(
    started, total_rewards, total_rewards_per_sec, undistributed_rewards,
    per_sec_per_provider_total_rewards_settled, period_finish, last_settle_time
) impure inline {
    var ds = get_data().begin_parse();
    var (
        bag_info, _, residue
    ) = (
        ds.load_ref(), ds.load_ref(), ds
    );
    var rewards_params = begin_cell()
        .store_uint(started, 1)
        .store_coins(total_rewards)
        .store_coins(total_rewards_per_sec)
        .store_coins(undistributed_rewards)
        .store_coins(per_sec_per_provider_total_rewards_settled)
        .store_uint(period_finish, 32)
        .store_uint(last_settle_time, 32)
        .end_cell();

    set_data(
        begin_cell()
            .store_ref(bag_info)
            .store_ref(rewards_params)
            .store_slice(residue)
            .end_cell()
    );
}

cell load_storage_providers_dict() inline {
    var ds = get_data().begin_parse();
    var (
        _, _, storage_providers, residue
    ) = (
        ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_ref(), ds
    );
    return storage_providers;
}

() save_storage_providers_dict(cell storage_providers_dict) impure inline {
    var ds = get_data().begin_parse();
    var (
        bag_info, rewards_params, _, residue
    ) = (
        ds.load_ref(), ds.load_ref(), ds.load_ref(), ds
    );
    set_data(
        begin_cell()
            .store_ref(bag_info)
            .store_ref(rewards_params)
            .store_ref(storage_providers_dict)
            .store_slices(residue)
            .end_cell()
    );

}

cell load_storage_provider_last_proof_times() inline {
    var ds = get_data().begin_parse();
    var (
        _, _, _, storage_provider_last_proof_times, residue
    ) = (
        ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_dict(), ds
    );

    return storage_provider_last_proof_times;
}

() save_storage_provider_last_proof_times(cell storage_provider_last_proof_times) impure inline {
    var ds = get_data().begin_parse();
    var (
        bag_info, rewards_params, storage_providers, _, residue
    ) = (
        ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_ref(), ds
    );
    set_data(
        begin_cell()
            .store_ref(bag_info)
            .store_ref(rewards_params)
            .store_ref(storage_providers)
            .store_ref(storage_provider_last_proof_times)
            .store_slices(residue)
            .end_cell()
    );
}

cell load_storage_provider_next_proofs() inline {
    var ds = get_data().begin_parse();
    var (
        _, _, _, _, storage_provider_next_proofs, residue
    ) = (
        ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_dict(), ds
    );
    return storage_provider_next_proofs;
}

() save_storage_provider_next_proofs(cell storage_provider_next_proofs) impure inline {
    var ds = get_data().begin_parse();
    var (
        bag_info, rewards_params, storage_providers, storage_provider_last_proof_times, storage_provider_next_proofs, _, residue
    ) = (
        ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_ref(), ds
    );
    set_data(
        begin_cell()
            .store_ref(bag_info)
            .store_ref(rewards_params)
            .store_ref(storage_providers)
            .store_ref(storage_provider_last_proof_times)
            .store_ref(storage_provider_next_proofs)
            .store_ref(storage_provider_next_proofs)
            .store_slices(residue)
            .end_cell()
    );

}

cell load_total_rewards_settled_and_unclaimed_for_providers() inline {
    var ds = get_data().begin_parse();
    var (
        _, _, _, _, _, _, total_rewards_settled_and_unclaimed_for_providers
    ) = (
        ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_dict()
    );
    return total_rewards_settled_and_unclaimed_for_providers;
}

() save_total_rewards_settled_and_unclaimed_for_providers(cell total_rewards_settled_and_unclaimed_for_providers) impure inline {
    var ds = get_data().begin_parse();
    var (
        bag_info, rewards_params, storage_providers, storage_provider_last_proof_times, storage_provider_next_proofs, _, residue
    ) = (
        ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_ref(), ds
    );
    set_data(
        begin_cell()
            .store_ref(bag_info)
            .store_ref(rewards_params)
            .store_ref(storage_providers)
            .store_ref(storage_provider_last_proof_times)
            .store_ref(storage_provider_next_proofs)
            .store_ref(total_rewards_settled_and_unclaimed_for_providers)
            .store_slices(residue)
            .end_cell()
    );
}

cell load_per_sec_total_rewards_settled_for_providers() inline {
    var ds = get_data().begin_parse();
    var (
        _, _, _, _, _, _, per_sec_total_rewards_settled_for_providers
    ) = (
        ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_dict()
    );
    return per_sec_total_rewards_settled_for_providers;
}

() save_per_sec_total_rewards_settled_for_providers(cell per_sec_total_rewards_settled_for_providers) impure inline {
    var ds = get_data().begin_parse();
    var (
         bag_info, rewards_params, storage_providers, storage_provider_last_proof_times, storage_provider_next_proofs, total_rewards_settled_and_unclaimed_for_providers, _
    ) = (
        ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_ref(), ds.load_ref()
    );
    set_data(
        begin_cell()
            .store_ref(bag_info)
            .store_ref(rewards_params)
            .store_ref(storage_providers)
            .store_ref(storage_provider_last_proof_times)
            .store_ref(storage_provider_next_proofs)
            .store_ref(total_rewards_settled_and_unclaimed_for_providers)
            .store_ref(per_sec_total_rewards_settled_for_providers)
            .end_cell()
    );
}

int total_storage_providers() inline {
    var storage_providers_dict = load_storage_providers_dict();
    return storage_providers_dict.dict_size();
}

int settle_time_applicable() inline {
    var (
        total_rewards, total_rewards_per_sec, undistributed_rewards,
        per_sec_per_provider_total_rewards_settled, period_finish, last_settle_time
    ) = load_rewards_params();
    return (now() <= period_finish) ? now() : period_finish;
}

int per_sec_per_provider_total_rewards_till_now() inline {
    var (
        total_rewards, total_rewards_per_sec, undistributed_rewards,
        per_sec_per_provider_total_rewards_settled, period_finish, last_settle_time
    ) = load_rewards_params();
    var total_providers = total_storage_providers();
    if (total_providers == 0) {
        return per_sec_per_provider_total_rewards_settled;
    }
    else {
        return per_sec_per_provider_total_rewards_settled + (
            (settle_time_applicable() - last_settle_time) * total_rewards_per_sec * (10 ^ 18) / total_providers / (10 ^ 18)
        );
    }
}

int per_sec_total_rewards_pending_settle_for_provider(slice provider_address) inline {
    return per_sec_per_provider_total_rewards_till_now() - 
        load_per_sec_total_rewards_settled_for_providers().dict_get(256, provider_address);
}

() do_settle_rewards(slice provider_address, int newWorker, int settle_new_rewards) impure {
    var per_sec_per_provider_total_rewards_settled = per_sec_per_provider_total_rewards_till_now();
    var last_settle_time = settle_time_applicable();
    if (newWorker) {
        var total_rewards_settled_and_unclaimed_for_providers = load_total_rewards_settled_and_unclaimed_for_providers();
        total_rewards_settled_and_unclaimed_for_providers.dict_set(256, provider_address, 0);
        save_total_rewards_settled_and_unclaimed_for_providers(total_rewards_settled_and_unclaimed_for_providers);
    }
    if (settle_new_rewards) {
        var pending_settled = per_sec_total_rewards_pending_settle_for_provider(provider_address);

        var total_rewards_settled_and_unclaimed_for_providers = load_total_rewards_settled_and_unclaimed_for_providers();
        var (earned, success?) = total_rewards_settled_and_unclaimed_for_providers.dict_get?(256, provider_address);
        if (success?) {
            total_rewards_settled_and_unclaimed_for_providers.dict_set(256, provider_address, earned + pending_settled);
        }

        save_total_rewards_settled_and_unclaimed_for_providers(total_rewards_settled_and_unclaimed_for_providers);
    }

    var per_sec_total_rewards_settled_for_providers = load_per_sec_total_rewards_settled_for_providers();
    per_sec_total_rewards_settled_for_providers.dict_set(256, provider_address, per_sec_per_provider_total_rewards_settled);
    save_per_sec_total_rewards_settled_for_providers(per_sec_total_rewards_settled_for_providers);

}

() register_as_provider(slice provider_address) impure {
    var storage_providers_dict = load_storage_providers_dict();
    var (_, success?) = storage_providers_dict.dict_get?(256, provider_address);
    if (success?) {
        throw(error::storage_provider_already_registered);
    }
    do_settle_rewards(provider_address, 1, 0);

    var first_worker = storage_providers_dict.dict_empty?();
    var (
        started, total_rewards, total_rewards_per_sec, undistributed_rewards,
        per_sec_per_provider_total_rewards_settled, period_finish, last_settle_time
    ) = load_rewards_params();
    if (~started & first_worker) {
        started = 1;
        total_rewards_per_sec = total_rewards / rewards_duration;
        last_settle_time = now();
        period_finish = now() + rewards_duration;
    }
    save_rewards_parms(
        started, total_rewards, total_rewards_per_sec, undistributed_rewards,
        per_sec_per_provider_total_rewards_settled, period_finish, last_settle_time
    );

    storage_providers_dict.dict_set(256, provider_address, 1);
    save_storage_providers_dict(storage_providers_dict);

    var last_work_report_time_dict = load_storage_provider_last_proof_times();
    last_work_report_time_dict.dict_set(256, provider_address, now());
    save_storage_provider_last_proof_times(last_work_report_time_dict);
}

() exit(slice provider_address) impure {
    var storage_providers_dict = load_storage_providers_dict();
    var (_, success?) = storage_providers_dict.dict_get?(256, provider_address);
    if (~success?) {
        throw(error::unregistered_storage_provider);
    }

    var pending_rewards = per_sec_total_rewards_pending_settle_for_provider(provider_address);
    var (
        started, total_rewards, total_rewards_per_sec, undistributed_rewards,
        per_sec_per_provider_total_rewards_settled, period_finish, last_settle_time
    ) = load_rewards_params();
    undistributed_rewards += pending_rewards;
    save_rewards_parms(
        started, total_rewards, total_rewards_per_sec, undistributed_rewards,
        per_sec_per_provider_total_rewards_settled, period_finish, last_settle_time
    );

    do_settle_rewards(provider_address, 0, 1);

    storage_providers_dict.dict_remove(256, provider_address);
    save_storage_providers_dict(storage_providers_dict);

    var last_work_report_time_dict = load_storage_provider_last_proof_times();
    last_work_report_time_dict.dict_remove(256, provider_address);
    save_storage_provider_last_proof_times(last_work_report_time_dict);
}

() claim_rewards(slice provider_address) impure {
    do_settle_rewards(provider_address, 0, 0);

    var total_rewards_settled_and_unclaimed_for_providers = load_total_rewards_settled_and_unclaimed_for_providers();
    var (earned, success?) = total_rewards_settled_and_unclaimed_for_providers.dict_get?(256, provider_address);
    if (success?) {
        total_rewards_settled_and_unclaimed_for_providers.dict_set(256, provider_address, 0);
        save_total_rewards_settled_and_unclaimed_for_providers(total_rewards_settled_and_unclaimed_for_providers);
        send_coins(provider_address, earned);
    }
}

() recycle(slice caller_address, slice to_address) impure {
    var (
        torrent_hash, owner_address, file_merkle_hash, file_size_in_bytes
    ) = load_bag_info();
    throw_unless(error::unauthorized, caller_address == owner_address);

    var (
        started, total_rewards, total_rewards_per_sec, undistributed_rewards,
        per_sec_per_provider_total_rewards_settled, period_finish, last_settle_time
    ) = load_rewards_params();
    throwunless(error::storage_order_unexpired, period_finish > 0 & (now() > period_finish));

    if (undistributed_rewards > 0) {
        send_coins(to_address, undistributed_rewards);
        undistributed_rewards = 0;
        save_rewards_parms(
            started, total_rewards, total_rewards_per_sec, undistributed_rewards,
            per_sec_per_provider_total_rewards_settled, period_finish, last_settle_time
        );
    }
}

int check_proof(int merkle_hash, int byte_to_proof, int file_size, cell file_dict_proof) {
    (slice cs, int special) = file_dict_proof.begin_parse_special();
    if (~ special) {
        return false;
    }
    if (cs~load_uint(8) != 3) { ;; Merkle proof
        return false;
    }
    if (cs~load_uint(256) != merkle_hash) {
        return false;
    }
    cell file_dict = cs~load_ref();
    int key_len = 0;
    while ((CHUNK_SIZE << key_len) < file_size) {
        key_len += 1;
    }
    (slice data, int found?) = file_dict.udict_get?(key_len, byte_to_proof / CHUNK_SIZE);
    if (found?) {
        return true;
    }
    return false;
}

() on_submit_storage_proof(slice provider_address, int valid) impure {
    var storage_providers_dict = load_storage_providers();
    var (_, success?) = storage_providers_dict.dict_get?(256, provider_address);
    if (~success?) {
        throw(error::unregistered_storage_provider);
    }
    if (~valid) {
        return ();
    }

    var last_work_report_time_dict = load_storage_provider_last_proof_times();
    var last_work_report_time = last_work_report_time_dict.dict_get(256, provider_address);
    var in_report_window = now() - last_work_report_time <= max_storage_proof_span;
    if (~in_report_window) {
        var (
            started, total_rewards, total_rewards_per_sec, undistributed_rewards,
            per_sec_per_provider_total_rewards_settled, period_finish, last_settle_time
        ) = load_rewards_params();
        undistributed_rewards += per_sec_total_rewards_pending_settle_for_provider(provider_address);
        save_rewards_parms(
            started, total_rewards, total_rewards_per_sec, undistributed_rewards,
            per_sec_per_provider_total_rewards_settled, period_finish, last_settle_time
        );
    }

    _do_settle_rewards(provider_address, 0, in_report_window);

    var last_work_report_time_dict = load_storage_provider_last_proof_times();
    last_work_report_time_dict.dict_set(256, provider_address, now());
    save_storage_provider_last_proof_times(last_work_report_time_dict);
}

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) { ;; ignore all bounced messages
        return ();
    }
    slice sender_address = cs~load_msg_addr();
    if (in_msg_body.slice_empty?()) {
        add_storage_fee(msg_value);
        return ();
    }

    int op = in_msg_body~load_uint(32);
    if (op == 0) {
        add_storage_fee(msg_value);
        return ();
    }

    int query_id = in_msg_body~load_uint(64);
    if (op == op::register_as_storage_provider) {
        register_as_provider(sender_address);
        return ();
    }
    if (op == unregister_as_storage_provider) {
        exit(sender_address);
        return ();
    }
    if (op == op::claim_storage_rewards) {
        claim_rewards(sender_address);
        return ();
    }

    if (op == op::submit_storage_proof) {
        cell file_dict_proof = in_msg_body~load_ref();

        var (
            torrent_hash, owner_address, file_merkle_hash, file_size_in_bytes
        ) = load_bag_info();
        var storage_provider_next_proofs_dict = load_storage_provider_next_proofs();
        var next_proof = storage_provider_next_proofs_dict.dict_get(256, sender_address);
        var valid = check_proof(file_merkle_hash, next_proof, file_size_in_bytes, file_dict_proof);

        on_submit_storage_proof(sender_address, valid);
        return ();
    }

    if (op == op::recycle_undistributed_storage_fees) {
        slice to_address = cs~load_msg_addr();
        recycle(sender_address, to_address);
        return ();
    }
}

int earned(slice provider_address) method_id {
    var total_rewards_settled_and_unclaimed_for_providers = load_total_rewards_settled_and_unclaimed_for_providers();
    var (earned, success?) = total_rewards_settled_and_unclaimed_for_providers.dict_get?(256, provider_address);
    if (success?) {
        return earned;
    }
    return 0;
}